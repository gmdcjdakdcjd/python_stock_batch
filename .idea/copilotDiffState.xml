<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ChartTest/YahooFinance_SEC.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ChartTest/YahooFinance_SEC.py" />
              <option name="originalContent" value="import yfinance as yf&#10;import matplotlib.pyplot as plt&#10;&#10;# 원하는 날짜로 변경 가능&#10;start_date = '2024-01-01'&#10;end_date = '2025-09-28'&#10;&#10;df = yf.download('005930.KS', start=start_date, end=end_date)&#10;if df.empty:&#10;    print('데이터가 없습니다.')&#10;else:&#10;    plt.figure(figsize=(9, 6))&#10;    plt.subplot(2, 1, 1)&#10;    plt.title('Samsung Electronics (Yahoo Finance)')&#10;    plt.plot(df.index, df['Close'], 'c', label='Close')&#10;    plt.plot(df.index, df['Adj Close'], 'b--', label='Adj Close')&#10;    plt.legend(loc='best')&#10;    plt.subplot(2, 1, 2)&#10;    plt.bar(df.index, df['Volume'], color='g', label='Volume')&#10;    plt.legend(loc='best')&#10;    plt.show()&#10;" />
              <option name="updatedContent" value="import yfinance as yf&#10;import matplotlib.pyplot as plt&#10;&#10;# 원하는 날짜로 변경 가능&#10;start_date = '2024-01-01'&#10;end_date = '2025-09-27'  # 오늘보다 하루 전으로 설정&#10;&#10;try:&#10;    df = yf.download('005930.KS', start=start_date, end=end_date)&#10;    if df.empty:&#10;        print('데이터가 없습니다.')&#10;    else:&#10;        plt.figure(figsize=(9, 6))&#10;        plt.subplot(2, 1, 1)&#10;        plt.title('Samsung Electronics (Yahoo Finance)')&#10;        plt.plot(df.index, df['Close'], 'c', label='Close')&#10;        plt.plot(df.index, df['Adj Close'], 'b--', label='Adj Close')&#10;        plt.legend(loc='best')&#10;        plt.subplot(2, 1, 2)&#10;        plt.bar(df.index, df['Volume'], color='g', label='Volume')&#10;        plt.legend(loc='best')&#10;        plt.show()&#10;except Exception as e:&#10;    print('에러 발생:', e)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/batch_code/trading/TradingStrategy/TripleScreen.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/batch_code/trading/TradingStrategy/TripleScreen.py" />
              <option name="originalContent" value="import pandas as pd&#10;import numpy as np&#10;from API import Analyzer&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#10;import random&#10;&#10;# -----------------------------&#10;# 1. DB 연결 및 기본 세팅&#10;# -----------------------------&#10;mk = Analyzer.MarketDB()&#10;company = mk.get_comp_info_optimization()&#10;stocks = list(company['name'])  # 전체 종목 사용&#10;name_to_code = {v: k for k, v in mk.codes.items()}&#10;&#10;print(f&quot; 총 {len(stocks)}개 종목 스캔 시작...&quot;)&#10;&#10;# -----------------------------&#10;# 2. 전략 실행 요약 저장 (1회 실행 로그)&#10;# -----------------------------&#10;result_id = save_strategy_summary(&#10;    strategy_name='TripleScreen_Trading',&#10;    signal_date=pd.Timestamp.today().strftime('%Y-%m-%d'),&#10;    signal_type='SCAN'&#10;)&#10;&#10;# -----------------------------&#10;# 3. 개별 종목 전략 계산&#10;# -----------------------------&#10;buy_signals = []&#10;sell_signals = []&#10;start_date = (pd.Timestamp.today() - pd.DateOffset(months=6)).strftime('%Y-%m-%d')&#10;&#10;for s in stocks:&#10;    try:&#10;        df = mk.get_daily_price(s, start_date)&#10;        if df is None or df.empty or len(df) &lt; 130:&#10;            continue&#10;&#10;        # --------------------------&#10;        # (1) MACD &amp; Signal 계산&#10;        # --------------------------&#10;        ema60 = df['close'].ewm(span=60).mean()&#10;        ema130 = df['close'].ewm(span=130).mean()&#10;        macd = ema60 - ema130&#10;        signal = macd.ewm(span=45).mean()&#10;        macdhist = macd - signal&#10;        df = df.assign(ema130=ema130, ema60=ema60, macd=macd, signal=signal, macdhist=macdhist).dropna()&#10;&#10;        # --------------------------&#10;        # (2) Stochastic SlowD 계산&#10;        # --------------------------&#10;        ndays_high = df['high'].rolling(window=14, min_periods=1).max()&#10;        ndays_low = df['low'].rolling(window=14, min_periods=1).min()&#10;        fast_k = (df['close'] - ndays_low) / (ndays_high - ndays_low) * 100&#10;        slow_d = fast_k.rolling(window=3).mean()&#10;        df = df.assign(fast_k=fast_k, slow_d=slow_d).dropna()&#10;&#10;        # --------------------------&#10;        # (3) 매수/매도 신호 계산&#10;        # --------------------------&#10;        last = df.iloc[-1]&#10;        date = df.index[-1].strftime('%Y-%m-%d')&#10;        price = float(last['close'])&#10;&#10;        # 매도 신호 (EMA 상승 전환 + SlowD 하락 돌파 20선)&#10;        if df.ema130.values[-2] &lt; df.ema130.values[-1] and \&#10;           df.slow_d.values[-2] &gt;= 20 and df.slow_d.values[-1] &lt; 20:&#10;            action = 'SELL'&#10;            sell_signals.append((s, price))&#10;        # 매수 신호 (EMA 하락 전환 + SlowD 상승 돌파 80선)&#10;        elif df.ema130.values[-2] &gt; df.ema130.values[-1] and \&#10;             df.slow_d.values[-2] &lt;= 80 and df.slow_d.values[-1] &gt; 80:&#10;            action = 'BUY'&#10;            buy_signals.append((s, price))&#10;        else:&#10;            continue&#10;&#10;        # --------------------------&#10;        # (4) DB 저장&#10;        # --------------------------&#10;        save_strategy_signal(&#10;            result_id=result_id,&#10;            code=name_to_code.get(s, 'UNKNOWN'),&#10;            name=s,&#10;            action=action,&#10;            price=price,&#10;            signal_date=date&#10;        )&#10;&#10;        print(f&quot;[{date}] {s} ({name_to_code.get(s, 'UNKNOWN')}) → {action} 신호 발생, 종가: {price:,.0f}&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;⚠️ {s} 처리 실패: {e}&quot;)&#10;&#10;# -----------------------------&#10;# 4. 결과 요약 출력&#10;# -----------------------------&#10;print(&quot;\n✅ 실행 완료&quot;)&#10;print(f&quot; 매수 신호: {len(buy_signals)}건&quot;)&#10;print(f&quot; 매도 신호: {len(sell_signals)}건&quot;)&#10;print(f&quot; DB 저장 완료 (result_id={result_id})&quot;)&#10;" />
              <option name="updatedContent" value="import pandas as pd&#10;import numpy as np&#10;from API import Analyzer&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#10;import random&#10;&#10;# -----------------------------&#10;# 1. DB 연결 및 기본 세팅&#10;# -----------------------------&#10;mk = Analyzer.MarketDB()&#10;company = mk.get_comp_info_optimization()&#10;stocks = list(company['name'])  # 전체 종목 사용&#10;name_to_code = {v: k for k, v in mk.codes.items()}&#10;&#10;print(f&quot; 총 {len(stocks)}개 종목 스캔 시작...&quot;)&#10;&#10;# -----------------------------&#10;# 2. 전략 실행 요약 저장 (1회 실행 로그)&#10;# -----------------------------&#10;result_id = save_strategy_summary(&#10;    strategy_name='TripleScreen_Trading',&#10;    signal_date=pd.Timestamp.today().strftime('%Y-%m-%d'),&#10;    signal_type='SCAN'&#10;)&#10;&#10;# -----------------------------&#10;# 3. 개별 종목 전략 계산&#10;# -----------------------------&#10;buy_signals = []&#10;sell_signals = []&#10;start_date = (pd.Timestamp.today() - pd.DateOffset(months=6)).strftime('%Y-%m-%d')&#10;&#10;for s in stocks:&#10;    try:&#10;        df = mk.get_daily_price(s, start_date)&#10;        if df is None or df.empty or len(df) &lt; 130:&#10;            continue&#10;&#10;        # --------------------------&#10;        # (1) MACD &amp; Signal 계산&#10;        # --------------------------&#10;        ema60 = df['close'].ewm(span=60).mean()&#10;        ema130 = df['close'].ewm(span=130).mean()&#10;        macd = ema60 - ema130&#10;        signal = macd.ewm(span=45).mean()&#10;        macdhist = macd - signal&#10;        df = df.assign(ema130=ema130, ema60=ema60, macd=macd, signal=signal, macdhist=macdhist).dropna()&#10;&#10;        # --------------------------&#10;        # (2) Stochastic SlowD 계산&#10;        # --------------------------&#10;        ndays_high = df['high'].rolling(window=14, min_periods=1).max()&#10;        ndays_low = df['low'].rolling(window=14, min_periods=1).min()&#10;        fast_k = (df['close'] - ndays_low) / (ndays_high - ndays_low) * 100&#10;        slow_d = fast_k.rolling(window=3).mean()&#10;        df = df.assign(fast_k=fast_k, slow_d=slow_d).dropna()&#10;&#10;        # --------------------------&#10;        # (3) 매수/매도 신호 계산&#10;        # --------------------------&#10;        last = df.iloc[-1]&#10;        date = df.index[-1].strftime('%Y-%m-%d')&#10;        price = float(last['close'])&#10;&#10;        # 매도 신호 (EMA 상승 전환 + SlowD 하락 돌파 20선)&#10;        if df.ema130.values[-2] &lt; df.ema130.values[-1] and \&#10;           df.slow_d.values[-2] &gt;= 20 and df.slow_d.values[-1] &lt; 20:&#10;            action = 'SELL'&#10;            sell_signals.append((s, price))&#10;        # 매수 신호 (EMA 하락 전환 + SlowD 상승 돌파 80선)&#10;        elif df.ema130.values[-2] &gt; df.ema130.values[-1] and \&#10;             df.slow_d.values[-2] &lt;= 80 and df.slow_d.values[-1] &gt; 80:&#10;            action = 'BUY'&#10;            buy_signals.append((s, price))&#10;        else:&#10;            continue&#10;&#10;        # --------------------------&#10;        # (4) DB 저장&#10;        # --------------------------&#10;        save_strategy_signal(&#10;            result_id=result_id,&#10;            code=name_to_code.get(s, 'UNKNOWN'),&#10;            name=s,&#10;            action=action,&#10;            price=price,&#10;            signal_date=date&#10;        )&#10;&#10;        print(f&quot;[{date}] {s} ({name_to_code.get(s, 'UNKNOWN')}) → {action} 신호 발생, 종가: {price:,.0f}&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;⚠️ {s} 처리 실패: {e}&quot;)&#10;&#10;# -----------------------------&#10;# 4. 결과 요약 출력&#10;# -----------------------------&#10;print(&quot;\n✅ 실행 완료&quot;)&#10;print(f&quot; 매수 신호: {len(buy_signals)}건&quot;)&#10;print(f&quot; 매도 신호: {len(sell_signals)}건&quot;)&#10;print(f&quot; DB 저장 완료 (result_id={result_id})&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>