<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ChartTest/YahooFinance_SEC.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ChartTest/YahooFinance_SEC.py" />
              <option name="originalContent" value="import yfinance as yf&#10;import matplotlib.pyplot as plt&#10;&#10;# 원하는 날짜로 변경 가능&#10;start_date = '2024-01-01'&#10;end_date = '2025-09-28'&#10;&#10;df = yf.download('005930.KS', start=start_date, end=end_date)&#10;if df.empty:&#10;    print('데이터가 없습니다.')&#10;else:&#10;    plt.figure(figsize=(9, 6))&#10;    plt.subplot(2, 1, 1)&#10;    plt.title('Samsung Electronics (Yahoo Finance)')&#10;    plt.plot(df.index, df['Close'], 'c', label='Close')&#10;    plt.plot(df.index, df['Adj Close'], 'b--', label='Adj Close')&#10;    plt.legend(loc='best')&#10;    plt.subplot(2, 1, 2)&#10;    plt.bar(df.index, df['Volume'], color='g', label='Volume')&#10;    plt.legend(loc='best')&#10;    plt.show()&#10;" />
              <option name="updatedContent" value="import yfinance as yf&#10;import matplotlib.pyplot as plt&#10;&#10;# 원하는 날짜로 변경 가능&#10;start_date = '2024-01-01'&#10;end_date = '2025-09-27'  # 오늘보다 하루 전으로 설정&#10;&#10;try:&#10;    df = yf.download('005930.KS', start=start_date, end=end_date)&#10;    if df.empty:&#10;        print('데이터가 없습니다.')&#10;    else:&#10;        plt.figure(figsize=(9, 6))&#10;        plt.subplot(2, 1, 1)&#10;        plt.title('Samsung Electronics (Yahoo Finance)')&#10;        plt.plot(df.index, df['Close'], 'c', label='Close')&#10;        plt.plot(df.index, df['Adj Close'], 'b--', label='Adj Close')&#10;        plt.legend(loc='best')&#10;        plt.subplot(2, 1, 2)&#10;        plt.bar(df.index, df['Volume'], color='g', label='Volume')&#10;        plt.legend(loc='best')&#10;        plt.show()&#10;except Exception as e:&#10;    print('에러 발생:', e)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/batch_code/trading/ETFTradingStrategy/DualMomentumBatch.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/batch_code/trading/ETFTradingStrategy/DualMomentumBatch.py" />
              <option name="originalContent" value="import pandas as pd&#10;import pymysql&#10;from datetime import datetime, timedelta&#10;from API import ETFAnalyzer&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#10;&#10;# --------------------------------------------------&#10;# DualMomentumBatch: ETF 듀얼 모멘텀 전략 배치 실행 클래스&#10;# --------------------------------------------------&#10;class DualMomentumBatch:&#10;    def __init__(self):&#10;        self.mk = ETFAnalyzer.MarketDB()  # ETF DB 객체 (ETF 정보 및 가격 데이터)&#10;        self.MIN_ABS_RETURN = 40.0  # 절대 모멘텀 필터 기준 (%)&#10;&#10;    def run_dual_momentum_batch(self, start_date, end_date, top_n=20):&#10;        &quot;&quot;&quot;&#10;        듀얼 모멘텀 배치 실행 (상대 모멘텀 상위 N개 + 절대 모멘텀 필터)&#10;        - DB에서 ETF 가격 데이터 조회&#10;        - 상대 모멘텀 상위 N개 추출&#10;        - 절대 모멘텀 기준 통과 종목만 DB 저장&#10;        &quot;&quot;&quot;&#10;        connection = pymysql.connect(&#10;            host='localhost', port=3306,&#10;            db='INVESTAR', user='root', passwd='0806', autocommit=True&#10;        )&#10;        cursor = connection.cursor()&#10;&#10;        # 날짜 보정 함수: 실제 거래일로 보정&#10;        def adjust_date(date_str):&#10;            sql = f&quot;SELECT MAX(date) FROM etf_daily_price WHERE date &lt;= '{date_str}'&quot;&#10;            cursor.execute(sql)&#10;            result = cursor.fetchone()&#10;            return result[0].strftime('%Y-%m-%d') if result and result[0] else None&#10;&#10;        start_date = adjust_date(start_date)&#10;        end_date = adjust_date(end_date)&#10;        print(f&quot;\n[DualMomentum 배치 실행] ({start_date} ~ {end_date})&quot;)&#10;&#10;        # 전체 ETF 종목 수익률 계산&#10;        rows = []  # [code, name, old_price, new_price, returns]&#10;        for code, name in self.mk.codes.items():&#10;            try:&#10;                cursor.execute(f&quot;SELECT close FROM etf_daily_price WHERE code='{code}' AND date='{start_date}'&quot;)&#10;                start_val = cursor.fetchone()&#10;                cursor.execute(f&quot;SELECT close FROM etf_daily_price WHERE code='{code}' AND date='{end_date}'&quot;)&#10;                end_val = cursor.fetchone()&#10;                if not start_val or not end_val:&#10;                    continue  # 가격 데이터 없으면 스킵&#10;&#10;                old_price, new_price = float(start_val[0]), float(end_val[0])&#10;                returns = (new_price / old_price - 1) * 100  # 수익률 계산&#10;                rows.append([code, name, old_price, new_price, returns])&#10;            except Exception:&#10;                continue  # 예외 발생시 해당 종목 스킵&#10;&#10;        connection.close()&#10;&#10;        if not rows:&#10;            print(&quot;데이터 없음: 수익률 계산 불가.&quot;)&#10;            print(&quot;ROWCOUNT=0&quot;)&#10;            print(&quot;CODECOUNT=0&quot;)&#10;            return pd.DataFrame()&#10;&#10;        # 상대 모멘텀 상위 N개 추출&#10;        df = pd.DataFrame(rows, columns=['code', 'name', 'old_price', 'new_price', 'returns'])&#10;        df_top = df.sort_values(by='returns', ascending=False).head(top_n)&#10;&#10;        print(&quot;\n[상대 모멘텀 상위 종목]&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;{'순위':&lt;4} {'종목명':&lt;20} {'수익률(%)':&gt;10} {'시작가':&gt;10} {'종가':&gt;10}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        for rank, row in enumerate(df_top.itertuples(), start=1):&#10;            print(f&quot;{rank:&lt;4} {row.name:&lt;20} {row.returns:&gt;10.2f} {row.old_price:&gt;10.0f} {row.new_price:&gt;10.0f}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        print(f&quot;상대 모멘텀 평균 수익률: {df_top['returns'].mean():.2f}%&quot;)&#10;        print(&quot;=&quot; * 70)&#10;&#10;        # 절대 모멘텀 필터 적용 (상위 N개 중 기준 초과만)&#10;        df_abs = df_top[df_top['returns'] &gt; self.MIN_ABS_RETURN].copy()&#10;&#10;        print(f&quot;\n[절대 모멘텀 통과 종목] (기준: {self.MIN_ABS_RETURN:.1f}%)&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;{'순위':&lt;4} {'종목명':&lt;20} {'수익률(%)':&gt;10} {'시작가':&gt;10} {'종가':&gt;10}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        for rank, row in enumerate(df_abs.itertuples(), start=1):&#10;            print(f&quot;{rank:&lt;4} {row.name:&lt;20} {row.returns:&gt;10.2f} {row.old_price:&gt;10.0f} {row.new_price:&gt;10.0f}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        print(f&quot;절대 모멘텀 평균 수익률: {df_abs['returns'].mean():.2f}%&quot;)&#10;        print(&quot;=&quot; * 70)&#10;&#10;        # DB 저장 (절대 모멘텀 통과 종목만)&#10;        print(f&quot;\n[DB 저장 대상] 절대 모멘텀 통과 {len(df_abs)}개 종목 (상위 {top_n} 중)&quot;)&#10;        result_id = save_strategy_summary(&#10;            strategy_name='DualMomentum',&#10;            signal_date=end_date,&#10;            signal_type='BATCH',&#10;            total_return=float(df_abs['returns'].mean()) if not df_abs.empty else 0.0&#10;        )&#10;&#10;        success_count = 0  # 저장 성공 종목 수&#10;        for rank, row in enumerate(df_abs.itertuples(), start=1):&#10;            try:&#10;                save_strategy_signal(&#10;                    result_id=result_id,&#10;                    code=row.code,&#10;                    name=row.name,&#10;                    action='TOP_ABS',&#10;                    price=float(row.new_price),&#10;                    old_price=float(row.old_price),&#10;                    returns=float(row.returns),&#10;                    rank_order=rank,&#10;                    signal_date=end_date&#10;                )&#10;                success_count += 1&#10;            except Exception as e:&#10;                print(f&quot;저장 실패: {row.name}, 사유: {e}&quot;)&#10;&#10;        print(f&quot;[DualMomentum 배치 저장 완료] (result_id={result_id})&quot;)&#10;        print(f&quot;ROWCOUNT={len(df_abs)}&quot;)&#10;        print(f&quot;CODECOUNT={success_count}&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        return df_abs&#10;&#10;&#10;if __name__ == '__main__':&#10;    # 6개월 기준 날짜 자동 계산&#10;    dm = DualMomentumBatch()&#10;    today = datetime.today()&#10;    start = (today - timedelta(days=90)).strftime('%Y-%m-%d')  # 90일(약 3개월)로 설정&#10;    end = today.strftime('%Y-%m-%d')&#10;    dm.run_dual_momentum_batch(start, end, top_n=20)&#10;" />
              <option name="updatedContent" value="import pandas as pd&#10;import pymysql&#10;from datetime import datetime, timedelta&#10;from API import ETFAnalyzer&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#10;&#10;# --------------------------------------------------&#10;# DualMomentumBatch: ETF 듀얼 모멘텀 전략 배치 실행 클래스&#10;# --------------------------------------------------&#10;class DualMomentumBatch:&#10;    def __init__(self):&#10;        self.mk = ETFAnalyzer.MarketDB()  # ETF DB 객체 (ETF 정보 및 가격 데이터)&#10;        self.MIN_ABS_RETURN = 40.0  # 절대 모멘텀 필터 기준 (%)&#10;&#10;    def run_dual_momentum_batch(self, start_date, end_date, top_n=20):&#10;        &quot;&quot;&quot;&#10;        듀얼 모멘텀 배치 실행 (상대 모멘텀 상위 N개 + 절대 모멘텀 필터)&#10;        - DB에서 ETF 가격 데이터 조회&#10;        - 상대 모멘텀 상위 N개 추출&#10;        - 절대 모멘텀 기준 통과 종목만 DB 저장&#10;        &quot;&quot;&quot;&#10;        connection = pymysql.connect(&#10;            host='localhost', port=3306,&#10;            db='INVESTAR', user='root', passwd='0806', autocommit=True&#10;        )&#10;        cursor = connection.cursor()&#10;&#10;        # 날짜 보정 함수: 실제 거래일로 보정&#10;        def adjust_date(date_str):&#10;            sql = f&quot;SELECT MAX(date) FROM etf_daily_price WHERE date &lt;= '{date_str}'&quot;&#10;            cursor.execute(sql)&#10;            result = cursor.fetchone()&#10;            return result[0].strftime('%Y-%m-%d') if result and result[0] else None&#10;&#10;        start_date = adjust_date(start_date)&#10;        end_date = adjust_date(end_date)&#10;        print(f&quot;\n[DualMomentum 배치 실행] ({start_date} ~ {end_date})&quot;)&#10;&#10;        # 전체 ETF 종목 수익률 계산&#10;        rows = []  # [code, name, old_price, new_price, returns]&#10;        for code, name in self.mk.codes.items():&#10;            try:&#10;                cursor.execute(f&quot;SELECT close FROM etf_daily_price WHERE code='{code}' AND date='{start_date}'&quot;)&#10;                start_val = cursor.fetchone()&#10;                cursor.execute(f&quot;SELECT close FROM etf_daily_price WHERE code='{code}' AND date='{end_date}'&quot;)&#10;                end_val = cursor.fetchone()&#10;                if not start_val or not end_val:&#10;                    continue  # 가격 데이터 없으면 스킵&#10;&#10;                old_price, new_price = float(start_val[0]), float(end_val[0])&#10;                returns = (new_price / old_price - 1) * 100  # 수익률 계산&#10;                rows.append([code, name, old_price, new_price, returns])&#10;            except Exception:&#10;                continue  # 예외 발생시 해당 종목 스킵&#10;&#10;        connection.close()&#10;&#10;        if not rows:&#10;            print(&quot;데이터 없음: 수익률 계산 불가.&quot;)&#10;            print(&quot;ROWCOUNT=0&quot;)&#10;            print(&quot;CODECOUNT=0&quot;)&#10;            return pd.DataFrame()&#10;&#10;        # 상대 모멘텀 상위 N개 추출&#10;        df = pd.DataFrame(rows, columns=['code', 'name', 'old_price', 'new_price', 'returns'])&#10;        df_top = df.sort_values(by='returns', ascending=False).head(top_n)&#10;&#10;        print(&quot;\n[상대 모멘텀 상위 종목]&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;{'순위':&lt;4} {'종목명':&lt;20} {'수익률(%)':&gt;10} {'시작가':&gt;10} {'종가':&gt;10}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        for rank, row in enumerate(df_top.itertuples(), start=1):&#10;            print(f&quot;{rank:&lt;4} {row.name:&lt;20} {row.returns:&gt;10.2f} {row.old_price:&gt;10.0f} {row.new_price:&gt;10.0f}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        print(f&quot;상대 모멘텀 평균 수익률: {df_top['returns'].mean():.2f}%&quot;)&#10;        print(&quot;=&quot; * 70)&#10;&#10;        # 절대 모멘텀 필터 적용 (상위 N개 중 기준 초과만)&#10;        df_abs = df_top[df_top['returns'] &gt; self.MIN_ABS_RETURN].copy()&#10;&#10;        print(f&quot;\n[절대 모멘텀 통과 종목] (기준: {self.MIN_ABS_RETURN:.1f}%)&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        print(f&quot;{'순위':&lt;4} {'종목명':&lt;20} {'수익률(%)':&gt;10} {'시작가':&gt;10} {'종가':&gt;10}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        for rank, row in enumerate(df_abs.itertuples(), start=1):&#10;            print(f&quot;{rank:&lt;4} {row.name:&lt;20} {row.returns:&gt;10.2f} {row.old_price:&gt;10.0f} {row.new_price:&gt;10.0f}&quot;)&#10;        print(&quot;-&quot; * 70)&#10;        print(f&quot;절대 모멘텀 평균 수익률: {df_abs['returns'].mean():.2f}%&quot;)&#10;        print(&quot;=&quot; * 70)&#10;&#10;        # DB 저장 (절대 모멘텀 통과 종목만)&#10;        print(f&quot;\n[DB 저장 대상] 절대 모멘텀 통과 {len(df_abs)}개 종목 (상위 {top_n} 중)&quot;)&#10;        result_id = save_strategy_summary(&#10;            strategy_name='DualMomentum',&#10;            signal_date=end_date,&#10;            signal_type='BATCH',&#10;            total_return=float(df_abs['returns'].mean()) if not df_abs.empty else 0.0&#10;        )&#10;&#10;        success_count = 0  # 저장 성공 종목 수&#10;        for rank, row in enumerate(df_abs.itertuples(), start=1):&#10;            try:&#10;                save_strategy_signal(&#10;                    result_id=result_id,&#10;                    code=row.code,&#10;                    name=row.name,&#10;                    action='TOP_ABS',&#10;                    price=float(row.new_price),&#10;                    old_price=float(row.old_price),&#10;                    returns=float(row.returns),&#10;                    rank_order=rank,&#10;                    signal_date=end_date&#10;                )&#10;                success_count += 1&#10;            except Exception as e:&#10;                print(f&quot;저장 실패: {row.name}, 사유: {e}&quot;)&#10;&#10;        print(f&quot;[DualMomentum 배치 저장 완료] (result_id={result_id})&quot;)&#10;        print(f&quot;ROWCOUNT={len(df_abs)}&quot;)&#10;        print(f&quot;CODECOUNT={success_count}&quot;)&#10;        print(&quot;=&quot; * 70)&#10;        return df_abs&#10;&#10;&#10;if __name__ == '__main__':&#10;    # 6개월 기준 날짜 자동 계산&#10;    dm = DualMomentumBatch()&#10;    today = datetime.today()&#10;    start = (today - timedelta(days=90)).strftime('%Y-%m-%d')  # 90일(약 3개월)로 설정&#10;    end = today.strftime('%Y-%m-%d')&#10;    dm.run_dual_momentum_batch(start, end, top_n=20)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/batch_code/trading/TradingStrategy/BollingerBand_Reversals.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/batch_code/trading/TradingStrategy/BollingerBand_Reversals.py" />
              <option name="originalContent" value="import pandas as pd&#10;from API import Analyzer&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#10;&#10;# -----------------------------&#10;# 1. DB 연결 및 전략 기본정보&#10;# -----------------------------&#10;mk = Analyzer.MarketDB()  # 마켓DB 객체 생성 (종목 정보 및 가격 데이터 접근)&#10;company = mk.get_comp_info_optimization()  # 최적화용 종목 정보 DataFrame&#10;stocks = list(company['name'])  # 종목명 리스트 추출&#10;name_to_code = {v: k for k, v in mk.codes.items()}  # 종목명→코드 매핑 딕셔너리&#10;&#10;print(f&quot;총 {len(stocks)}개 종목 스캔 시작...&quot;)&#10;&#10;# -----------------------------&#10;# 2. 전략 실행 요약 저장 (1회 실행 로그)&#10;# -----------------------------&#10;result_id = save_strategy_summary(&#10;    strategy_name='BollingerBand_Reversal',  # 전략명&#10;    signal_date=pd.Timestamp.today().strftime('%Y-%m-%d'),  # 실행일&#10;    signal_type='SCAN'  # 실행 타입&#10;)&#10;&#10;# -----------------------------&#10;# 3. 개별 종목 전략 계산&#10;# -----------------------------&#10;buy_signals = []  # 매수 신호 저장 리스트&#10;sell_signals = []  # 매도 신호 저장 리스트&#10;start_date = (pd.Timestamp.today() - pd.DateOffset(months=6)).strftime('%Y-%m-%d')  # 6개월 전부터 데이터 조회&#10;&#10;for s in stocks:&#10;    try:&#10;        df = mk.get_daily_price(s, start_date)  # 개별 종목의 6개월치 가격 데이터 조회&#10;        if df is None or df.empty or len(df) &lt; 21:&#10;            continue  # 데이터 부족시 스킵&#10;&#10;        # Bollinger Band 계산&#10;        df['MA20'] = df['close'].rolling(window=20).mean()  # 20일 이동평균&#10;        df['stddev'] = df['close'].rolling(window=20).std()  # 20일 표준편차&#10;        df['upper'] = df['MA20'] + (df['stddev'] * 2)  # 상단 밴드&#10;        df['lower'] = df['MA20'] - (df['stddev'] * 2)  # 하단 밴드&#10;        df['PB'] = (df['close'] - df['lower']) / (df['upper'] - df['lower'])  # %B 지표&#10;        df['II'] = (2 * df['close'] - df['high'] - df['low']) / (df['high'] - df['low']) * df['volume']  # 매집/이탈 지표&#10;        df['IIP21'] = df['II'].rolling(window=21).sum() / df['volume'].rolling(window=21).sum() * 100  # 21일 누적 매집/이탈&#10;        df = df.dropna()  # 결측치 제거&#10;&#10;        # 최근 거래일 데이터 기준으로 판단&#10;        last = df.iloc[-1]&#10;        date = df.index[-1].strftime('%Y-%m-%d')&#10;        price = float(last['close'])&#10;        pb = float(last['PB'])&#10;        iip = float(last['IIP21'])&#10;&#10;        # 매수/매도 신호 조건&#10;        if pb &lt; 0.05 and iip &gt; 0:&#10;            action = 'BUY'&#10;            buy_signals.append((s, price))&#10;        elif pb &gt; 0.95 and iip &lt; 0:&#10;            action = 'SELL'&#10;            sell_signals.append((s, price))&#10;        else:&#10;            continue&#10;&#10;        # 전략 신호 DB 저장&#10;        save_strategy_signal(&#10;            result_id=result_id,&#10;            code=name_to_code.get(s, 'UNKNOWN'),&#10;            name=s,&#10;            action=action,&#10;            price=price,&#10;            signal_date=date  # ✅ 날짜 저장&#10;        )&#10;&#10;        print(f&quot;[{date}] {s} ({name_to_code.get(s, 'UNKNOWN')}) → {action} 신호 발생, 종가: {price:,.0f}&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;{s} 처리 실패: {e}&quot;)&#10;&#10;# -----------------------------&#10;# 4. 요약 출력&#10;# -----------------------------&#10;print(&quot;\n실행 완료&quot;)&#10;print(f&quot;매수 신호: {len(buy_signals)}건&quot;)&#10;print(f&quot;매도 신호: {len(sell_signals)}건&quot;)&#10;print(f&quot;DB 저장 완료 (result_id={result_id})&quot;)&#10;&#10;&#10;print(f&quot;ROWCOUNT={len(buy_signals) + len(sell_signals)}&quot;)&#10;print(f&quot;CODECOUNT={len(buy_signals) + len(sell_signals)}&quot;)&#10;&#10;print(f&quot;DB 저장 완료 (result_id={result_id})&quot;)" />
              <option name="updatedContent" value="import pandas as pd&#13;&#10;from API import Analyzer&#13;&#10;from batch_code.trading.db_saver import save_strategy_summary, save_strategy_signal&#13;&#10;&#13;&#10;# -----------------------------&#13;&#10;# 1. DB 연결 및 전략 기본정보&#13;&#10;# -----------------------------&#13;&#10;mk = Analyzer.MarketDB()  # 마켓DB 객체 생성 (종목 정보 및 가격 데이터 접근)&#13;&#10;company = mk.get_comp_info_optimization()  # 최적화용 종목 정보 DataFrame&#13;&#10;stocks = list(company['name'])  # 종목명 리스트 추출&#13;&#10;name_to_code = {v: k for k, v in mk.codes.items()}  # 종목명→코드 매핑 딕셔너리&#13;&#10;&#13;&#10;print(f&quot;총 {len(stocks)}개 종목 스캔 시작...&quot;)&#13;&#10;&#13;&#10;# -----------------------------&#13;&#10;# 2. 전략 실행 요약 저장 (1회 실행 로그)&#13;&#10;# -----------------------------&#13;&#10;result_id = save_strategy_summary(&#13;&#10;    strategy_name='BollingerBand_Reversal',  # 전략명&#13;&#10;    signal_date=pd.Timestamp.today().strftime('%Y-%m-%d'),  # 실행일&#13;&#10;    signal_type='SCAN'  # 실행 타입&#13;&#10;)&#13;&#10;&#13;&#10;# -----------------------------&#13;&#10;# 3. 개별 종목 전략 계산&#13;&#10;# -----------------------------&#13;&#10;buy_signals = []  # 매수 신호 저장 리스트&#13;&#10;sell_signals = []  # 매도 신호 저장 리스트&#13;&#10;start_date = (pd.Timestamp.today() - pd.DateOffset(months=6)).strftime('%Y-%m-%d')  # 6개월 전부터 데이터 조회&#13;&#10;&#13;&#10;for s in stocks:&#13;&#10;    try:&#13;&#10;        df = mk.get_daily_price(s, start_date)  # 개별 종목의 6개월치 가격 데이터 조회&#13;&#10;        if df is None or df.empty or len(df) &lt; 21:&#13;&#10;            continue  # 데이터 부족시 스킵&#13;&#10;&#13;&#10;        # Bollinger Band 계산&#13;&#10;        df['MA20'] = df['close'].rolling(window=20).mean()  # 20일 이동평균&#13;&#10;        df['stddev'] = df['close'].rolling(window=20).std()  # 20일 표준편차&#13;&#10;        df['upper'] = df['MA20'] + (df['stddev'] * 2)  # 상단 밴드&#13;&#10;        df['lower'] = df['MA20'] - (df['stddev'] * 2)  # 하단 밴드&#13;&#10;        df['PB'] = (df['close'] - df['lower']) / (df['upper'] - df['lower'])  # %B 지표&#13;&#10;        df['II'] = (2 * df['close'] - df['high'] - df['low']) / (df['high'] - df['low']) * df['volume']  # 매집/이탈 지표&#13;&#10;        df['IIP21'] = df['II'].rolling(window=21).sum() / df['volume'].rolling(window=21).sum() * 100  # 21일 누적 매집/이탈&#13;&#10;        df = df.dropna()  # 결측치 제거&#13;&#10;&#13;&#10;        # 최근 거래일 데이터 기준으로 판단&#13;&#10;        last = df.iloc[-1]&#13;&#10;        date = df.index[-1].strftime('%Y-%m-%d')&#13;&#10;        price = float(last['close'])&#13;&#10;        pb = float(last['PB'])&#13;&#10;        iip = float(last['IIP21'])&#13;&#10;&#13;&#10;        # 매수/매도 신호 조건&#13;&#10;        if pb &lt; 0.05 and iip &gt; 0:&#13;&#10;            action = 'BUY'&#13;&#10;            buy_signals.append((s, price))&#13;&#10;        elif pb &gt; 0.95 and iip &lt; 0:&#13;&#10;            action = 'SELL'&#13;&#10;            sell_signals.append((s, price))&#13;&#10;        else:&#13;&#10;            continue&#13;&#10;&#13;&#10;        # 전략 신호 DB 저장&#13;&#10;        save_strategy_signal(&#13;&#10;            result_id=result_id,&#13;&#10;            code=name_to_code.get(s, 'UNKNOWN'),&#13;&#10;            name=s,&#13;&#10;            action=action,&#13;&#10;            price=price,&#13;&#10;            signal_date=date  # ✅ 날짜 저장&#13;&#10;        )&#13;&#10;&#13;&#10;        print(f&quot;[{date}] {s} ({name_to_code.get(s, 'UNKNOWN')}) → {action} 신호 발생, 종가: {price:,.0f}&quot;)&#13;&#10;&#13;&#10;    except Exception as e:&#13;&#10;        print(f&quot;{s} 처리 실패: {e}&quot;)&#13;&#10;&#13;&#10;# -----------------------------&#13;&#10;# 4. 요약 출력&#13;&#10;# -----------------------------&#13;&#10;print(&quot;\n실행 완료&quot;)&#13;&#10;print(f&quot;매수 신호: {len(buy_signals)}건&quot;)&#13;&#10;print(f&quot;매도 신호: {len(sell_signals)}건&quot;)&#13;&#10;print(f&quot;DB 저장 완료 (result_id={result_id})&quot;)&#13;&#10;&#13;&#10;&#13;&#10;print(f&quot;ROWCOUNT={len(buy_signals) + len(sell_signals)}&quot;)&#13;&#10;print(f&quot;CODECOUNT={len(buy_signals) + len(sell_signals)}&quot;)&#13;&#10;&#13;&#10;print(f&quot;DB 저장 완료 (result_id={result_id})&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>